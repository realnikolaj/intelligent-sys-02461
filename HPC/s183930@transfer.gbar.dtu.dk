# -*- coding: utf-8 -*-
"""
Created on Mon Jan  7 10:39:20 2019

@author: daghn
"""

import numpy as np
import math
import torch
import torch.utils.data
import pickle
#np.set_printoptions(suppress=True)


# Initialize Hyper-parameters

picture_dimension = 28 # Default is 28

input_size = picture_dimension**2       # The image size = dimension squared
hidden_size = picture_dimension**2     # The number of nodes at the hidden layer

# number of circles and classes
num_circles_min = 0 
num_circles_max = 3
num_classes = num_circles_max + 1
   
# Size of datasets
N = 100000            # Size of train dataset
V = 10000      # Size of test dataset




def create_image():
    area_min = 0.05
    area_max = 0.20
    
    min_circle_area = 0.2 #minimum area of circle relative to the max 1
    
    margin = 1   # margin, a number of pixels
    circle_buffer = 1.10
    
    # Create empty picture
    picture = np.zeros((picture_dimension, picture_dimension))
    
    # Randomly pick number of circles
    number_of_circles = np.random.randint(num_circles_min, num_circles_max + 1)
    
    # Randomly pick the total area of circles, relative to the picture area
    total_area_of_circles = np.random.uniform(low = area_min, high = area_max)
    
    # Create array of circle data.
    # 5 columns: area, radius, scaled radius, x-coor., y-coor.
    circle_data = np.zeros((number_of_circles, 5))
    
    # Calculate circle areas:
    # First pick random areas relative to max 1
    circle_areas = np.array(np.random.uniform(min_circle_area, 1, number_of_circles))
    
    # Then scale so they sum up to 1, and then multipy with the total area of circles and total area of picture
    # (which is relative to the full image area)
    circle_areas = (circle_areas / np.sum(circle_areas)) * total_area_of_circles
    
    # store the areas in the circle data array
    circle_data[:,0] = circle_areas
    
    # Calculate circle radii
    circle_data[:,1] = np.sqrt(circle_data[:,0]/3.1415) 
    
    # Calculate scaled circle radii
    circle_data[:,2] = circle_data[:,1] * picture_dimension
    
    # Sort circles by size
    circle_data = circle_data[circle_data[:,0].argsort()]
    circle_data = circle_data[::-1]
    
    # Place circles
    for i in range(number_of_circles):
        looking_for_centrum = True
        count = 1
        stop = 1000000
        
        while looking_for_centrum == True and count < stop:
            radius = circle_data[i,2]
            x = np.random.randint(margin + radius, picture_dimension - margin - radius)
            y = np.random.randint(margin + radius, picture_dimension - margin - radius)
            looking_for_centrum = False
            
            for j in range(0, i):
                radius_old = circle_data[j,2]
                x_old = circle_data[j,3]
                y_old = circle_data[j,4]
                
                distance = math.sqrt((x - x_old)**2 + (y - y_old)**2)
                
                if distance < circle_buffer * (radius + radius_old):
                    looking_for_centrum = True
                    break
                
            if looking_for_centrum == False:
                circle_data[i,3] = x
                circle_data[i,4] = y
                   
            count += 1
            if count == stop:
                break
#                print("couldn't place circle")
    
    # Update picture
    for i in range(number_of_circles):
        radius = circle_data[i,2]
        R = int(math.ceil(radius))
        x = int(circle_data[i,3])
        y = int(circle_data[i,4])
        
        # Checking all pixels in a sqared box around the circle. If their 
        # distance to the center is less than the radius, we color the pixel.
        box_size = 2 * R + 1        
        
        for j in range(box_size):
            for k in range(box_size):
                if (j - (R + 1))**2 + (k - (R + 1))**2 < radius**2:
                    picture[x - R + j, y - R + k] = 1        
    
#    print(circle_data)
#    print(picture.dtype)
#    
#    plt.imshow(picture)
#    plt.show()
    
    label = number_of_circles
    
    return (picture, label)

def create_dataset(N):
    
    # Create list of N pictures and corresponding list of N labels
    picture_list = []
    label_list = []
    for i in range(N):
        
        # Feedback for process on large images

        # Create one picture
        picture, label = create_image()
        
        # Convert picture from (nxn) to (1xnxn) shape (suitable for torch format)
        picture = picture[np.newaxis, ...]
        
        # Append picture and label to lists
        picture_list.append(picture)
        label_list.append(label)
    
    # Convert to np arrays    
    pictures = np.array(picture_list)
    labels = np.array(label_list)    
    
#    print(pictures.shape)
#    print(labels.shape)
    
    # Convert to torch tensors
    our_data = torch.from_numpy(pictures)
    our_labels = torch.from_numpy(labels)
    
#    print(data.shape)
#    print(labels.shape)
    
    # Encapsulate into a TensorDataset:
    dataset = torch.utils.data.TensorDataset(our_data, our_labels)
    
    return dataset
    


train_dataset = create_dataset(N)
test_dataset = create_dataset(V)

NN = len(str(N).replace('.',''))-1
VV = len(str(V).replace('.',''))-1

pickle_out = open("train{}e{}_{}.pickle".format(int(N/10**(NN)),NN,num_circles_max),"wb")
pickle.dump([train_dataset,N], pickle_out)
pickle_out.close()

pickle_out = open("test{}e{}_{}.pickle".format(int(V/10**(VV)),VV,num_circles_max),"wb")
pickle.dump([test_dataset,V], pickle_out)
pickle_out.close()

    

